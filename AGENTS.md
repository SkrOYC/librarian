AGENTS.md

This file provides guidance to AI Agents when working with code in this repository.
These instructions guide you to focus on project-specific architecture and commands rather than generic development advice, and to base the content on actual analysis of the codebase rather than assumptions.

# Librarian CLI - Technology Research Agent

This document provides essential guidance for AI agents working with the Librarian CLI codebase.

## Project Overview

Librarian CLI is a technology research agent that enables AI coding agents to query specific technology repositories and receive detailed technical responses through autonomous exploration. It uses a LangChain-powered ReAct agent with sandboxed tools for file operations.

## Development Commands

### Building
```bash
# Build the standalone executable with Nix (recommended)
nix build .#default

# Run directly with Nix
nix run .#default -- --help

# Development build with Bun
bun run build

# Development build (TypeScript compilation)
bun run build:dev
```

### Testing
```bash
# Run all tests
bun run test

# Run tests in watch mode
bun run test:watch

# Run a specific test file
bun test tests/[test-file-name].test.ts

# Run tests with coverage
bun test --coverage
```

### Linting and Formatting
```bash
# Lint the codebase
bun run lint

# Format code (using Biome)
bunx biome check --write src/
```

### Development Workflow
```bash
# Install dependencies
bun install

# Start development
bun run build && bun run cli

# Run the CLI directly
bun dist/cli.js [arguments]
```

## Architecture Overview

### Core Components

1. **CLI Entry Point** (`src/cli.ts`) - Command parsing with Commander.js and configuration loading
2. **Core Librarian** (`src/index.ts`) - Main orchestrator for operations and repository synchronization
3. **Repository Manager** (`src/repo/`) - Git operations and repository management
4. **Agent Orchestrator** (`src/agent/`) - LangChain createAgent implementation with dynamic prompts
5. **LLM Provider** (`src/llm/`) - LangChain unified model abstraction via `initChatModel`
6. **Agent Tools** (`src/tools/`) - Sandboxed file operations (listing, reading, grep, glob)

### Agent Tools Architecture

The agent includes four core tools with security sandboxing:
- **File Listing** (`src/tools/file-listing.tool.ts`) - List files and directories within sandboxed working directory
- **File Reading** (`src/tools/file-reading.tool.ts`) - Read file contents with path validation
- **Grep Search** (`src/tools/grep-content.tool.ts`) - Search file contents using regex patterns
- **Glob Search** (`src/tools/file-finding.tool.ts`) - Find files by name patterns using glob syntax

### Security Sandboxing

The system implements robust sandboxing to prevent unauthorized file access:
- All tools operate within isolated working directories: `{repos_path}/{group}/{technology}`
- Path validation prevents directory traversal attacks (e.g., `../` escapes)
- Absolute path validation ensures tools can't access files outside the sandbox
- The `verify-sandboxing.ts` script provides end-to-end security testing
- Context validation ensures all file operations have proper working directory context

### Configuration Loading

Configuration is loaded from `~/.config/librarian/config.yaml` with validation and support for:
- Environment variable loading from `.env` files
- Backward compatibility with README-style keys (`llm_provider`, `llm_model`, etc.)
- Path normalization and security validation
- Default configuration creation when file doesn't exist

### Logging System

The system uses a comprehensive logging system (`src/utils/logger.ts`) that:
- Creates timestamped log files in `~/.config/librarian/logs/`
- Redacts sensitive information (API keys, paths, URLs)
- Supports different log levels (INFO, DEBUG, WARN, ERROR)
- Includes performance timing measurements
- Logs to files silently with no impact on application performance

## Nix and bun2nix Configuration

### Building Standalone Executable
The project uses Nix with bun2nix to create a standalone executable (~4MB) instead of bundling the full Bun runtime (~126MB).

### bun2nix Overview
`bun2nix` is a fast Rust-based tool that converts Bun's `bun.lock` lock-file to Nix expressions for reproducible builds. It generates the `bun.nix` file which contains fetchurl expressions for all dependencies.

### bun.lock and bun.nix Relationship
- `bun.lock`: Bun's native lock-file containing dependency information (similar to package-lock.json or yarn.lock)
- `bun.nix`: Generated Nix expression containing fetchurl calls for all dependencies, created from `bun.lock` by the bun2nix tool
- The `bun.nix` file is generated by running `bunx bun2nix -o bun.nix` and should be committed to the repository

### Critical Agent Instructions

**Dependency Management**:
- For development: Use `bun install` to install dependencies locally (generates/updates `bun.lock`)
- For Nix builds: Dependencies are managed by Nix via `bun.nix` (generated from `bun.lock` by bun2nix)
- After any dependency changes in `package.json`, run `bun install` then `bunx bun2nix -o bun.nix` to update the Nix configuration
- The Nix sandbox cannot access npm registry directly, so changes to `package.json` must be followed by bun2nix regeneration

**Development workflow**:
1. Edit `package.json` for dependency changes
2. Run `bun install` to update `bun.lock`
3. Run `bunx bun2nix -o bun.nix` to regenerate `bun.nix` from the updated lock file
4. Run `nix build .#default` to verify the build
5. Commit both `package.json`, `bun.lock`, and `bun.nix` changes

**Note**: The `postinstall` script in `package.json` runs `bunx bun2nix -o bun.nix` to keep `bun.nix` synchronized with `bun.lock` automatically after each `bun install`.

**DO NOT commit `node_modules` or build artifacts**:
- `node_modules/` is already in `.gitignore`
- Build output goes to Nix store, not the project directory

## Configuration and Environment

### Configuration Schema
Configuration is loaded from `~/.config/librarian/config.yaml` with the following structure:
```yaml
repos_path: "~/.local/share/librarian/repos"
technologies:
  default: # Group name
    react: # Technology name
      repo: "https://github.com/facebook/react.git"
      branch: "main" # Optional, defaults to main/master
      description: "JavaScript library for building user interfaces"
aiProvider: # or llm_provider for backward compatibility
  type: openai # Options: openai, anthropic, google, openai-compatible, claude-code, gemini-cli
  apiKey: # API key (loaded from .env as LIBRARIAN_API_KEY if not provided)
  model: gpt-5.2
  baseURL: # Optional for openai-compatible providers
```

### Supported LLM Providers
- OpenAI (via @langchain/openai)
- Anthropic (via @langchain/anthropic) 
- Google (via @langchain/google-genai)
- OpenAI-compatible providers (via LangChain's unified interface)
- Claude CLI (requires `claude` command in PATH)
- Gemini CLI (requires `gemini` command in PATH)

## Testing Strategy

The codebase includes comprehensive tests covering:
- Integration tests (`cli-integration.test.ts`) - End-to-end CLI functionality
- Security tests (`security.test.ts`, `tool-sandboxing.test.ts`) - Path validation and sandboxing
- Tool tests (`modern-file-*.test.ts`) - Individual tool functionality
- Configuration tests (`config.test.ts`, `config-schema.test.ts`) - Configuration loading and validation
- Repository tests (`repository.test.ts`) - Git operations and synchronization
- Context integration tests (`tool-context-integration.test.ts`) - Agent context handling

## Key Files and Directories

- `flake.nix` - Nix flake configuration with packages, apps, and devShells
- `default.nix` - Nix derivation for building the standalone executable
- `package.json` - Dependencies and scripts (managed via bun2nix)
- `bun.nix` - Auto-generated reproducible dependency configuration
- `src/agents/react-agent.ts` - Core LangChain agent implementation
- `src/agents/context-schema.ts` - Zod schemas for agent context validation
- `verify-sandboxing.ts` - Security verification script
- `src/utils/logger.ts` - Comprehensive logging system with redaction
- `src/config.ts` - Configuration loading with validation and environment support